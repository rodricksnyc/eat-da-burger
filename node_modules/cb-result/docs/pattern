     Introduction:
     Problems:
     Solution:
     Example:
         Classical:
         result.cb:
     Proposal:
     Appendix:

 Introduction:

 result object is a utility class with several methods that help with the error handling in the back-end code. It solves several problems that we have in the classical callback parameters (err, data). It greatly increases readability, reduces maintenance, minimizes the surface area for bugs and gives centralized error management/translation/logging.


 Problems:

 The following is the set of problems that come from using the classical callbacks.

     err can be many types:

         third party errors
         custom library errors
         exception errors

     Boxing the different types of errors into usually one format that is custom used inside the module you are coding.
     Making sure you don't wrap (box) the errors that are already wrapped while bubbling up through the callbacks.
     Writing generic and custom handling code in each callback, this greatly reduces readability, increases the maintenance and increases the surface area for bugs because of a code repetition.
         For example you would need to check for insert errors that fail because of duplicate constraints.
     Making false assumptions about the err received, for example, assuming that calling a function that deals with database will only trigger database related errors.
     Making false assumptions about intermediate functions. While consuming intermediate functions, the developer must check the code of that function to have a good idea of what sort of errors they may trigger and the developer will need to note whether it sends the errors wrapped into the custom format or not, or perhaps both. The developer should not need to know "anything" about the errors a function could trigger.
     Custom error codes are scattered across modules.
     The above points also apply to catch statements and translating catch errors into callback errors.

 The following is a link to a page that describes these problems in greater detail.


 Solution:

 All functions should pass through a common function "result.cb" which does the following:

     Automatically deal with errors.
     Translate errors (centralized) into one common format that any function can assume it will get this format always.
     Log selective errors as needed.
     Flexibility in translating the errors, including regex for translating third party errors into custom error codes.
     One source of error code definitions.
     Error code definitions can include custom data targeted for specific layers, for example, it could contain httpCode that could modify the http result code of the http response.
     Box/Unbox errors as needed.
     Optionally take success function that will be called upon success only (in the majority of the cases).
     Optionally take error function that will be called for cleanup purposes.
     Simplify callback parameters into one parameter instead of two.
         use cb(result.success("any data payload")).
         use cb(result.error("any error payload"));
     Expose different levels of information via verbose level, possibly for different environments. For example you could in "dev" environments expose more detail about the source of the error and stack trace, while in "production" you only expose error codes or the logged id of the error.
     Maintain backward compatibility via few result object helper functions.
     use result.legacycb instead of result.cb to bubble up using the classical cb (sometimes needed, for example "async" library functions)

 All these concepts are best described using an example.


 Example:

 Please read the comments inside the examples for more information.
 Classical:
 // classical method:
 // 1. low readability
 // 2. deal with error in every stage
 // 3. high surface area for bugs
 // 4. a lot of dependency between specific function logic/error handling/error translation
 // 5. localized error translation.

 function f1(data, cb) {
     f2(data, function(err, data) {
         if (err)
             return cb(err); // Perhaps here we need to wrap this error? Maybe it is wrapped already?
         else {
             f3db(data, function(err, data) { // Developer "knows" that this is a database calling function and does some assumptions on the type of errors that could get triggered.
                 if (err) {
                     if (/^E11000/.test(err)) // localized custom error translation based on needing to know what function f3db does.
                         return cb(new FcError(10, err)); // here error code 10 indicates data unique constraint problem.
                     else
                         return cb(err);
                 }
                 else {
                     f4(data, function(err, finaldata) {
                         if (err)
                             cb(err); // deal with errors in every step, a lot of repeated code, chance to introduce bugs.
                         else
                             cb(null, finaldata);
                     });
                 }
             });
         }
     });
 }
 result.cb:
 // using result:
 // 1. better readability,
 // 2. no need to deal with errors in your code, errors are dealt with correctly in a centralized manner, wrapped into common structures (if needed), translated via regex or other custom code.
 // 3. lower surface for bugs, the developer only writes code that deals with success logic.
 // 4. no dependency between specific function logic/error handling.
 // 5. full flexibility is maintained via few additional helper functions of result object.

 function f1(data, cb) {
     f2(data, result.cb(cb, function(data) {
         f3db(data, result.cb(cb, function(data) {
             f4(data, result.cb(cb, function(finaldata) {
                 return cb(result.success(finaldata));
             }));
         }));
     }));
 }


 Proposal:

 The result object and result.cb pattern are proposed to be used in the new enforcement rules that we will have. The result object should be used across all code (all layers) to enable a common output or a common result approach. This simplifies coding across all layers and insures a unified error handling system along with unified error codes. Adding additional helper functions to result object for translating to different communication layers. (Example: A helper function to translate the result into proper http response, another helper function to do the same for RPC)

 The result object and errors.js should be moved into a common utility library accessible to all our nodejs modules.


 Appendix:

     A more detailed look at the result object.


