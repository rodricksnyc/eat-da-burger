    The different ways you get errors:
    Two different methods in dealing with errors and their assumption:
    Samples of code that does this assumption:
    The problem:
    Solution:
    Sample of the solution code:
    Additional benefits:
    Cons:

The different ways you get errors:

Any method that needs to deal with an error object whether it does it by callback or catch statement, it may encounter different types of error objects

    It may encounter a generic error object from libraries such us the native mongodb or any other native nodejs library, they use the approach of callbacks with two parameters, the first being error object (if exists) and the second being a data object (if needed)
    It may encounter an error object that is created by the specific layer it is in, usually these are the most common and they follow a common structure, (example, FcError). These include both warnings and fatal errors.
    It may encounter other error objects like built in type Error or similar in catch statements specifically. 
    It may also encounter Error in callbacks, if a function at a certain level decides to catch errors and return them inside callbacks.

Two different methods in dealing with errors and their assumption:

    Many functions are written with a certain assumption, for example, if the function is calling mongodb code, it knows that the returned error object will be in the native format in callback (err, data)
    Other functions call lower functions and assume that errors returned from them are errors created by the developer with a specific structure (example, FcError).
        Example function login, calls another function authenticate which has mongodb code. 
        login assumes that authenticate should always return errors with custom format, which means authenticate should take all mongodb errors and wrap them with the custom error format.
    So here we have two different "responsibilities", a set of functions are wrapping generic errors into custom errors, another set of functions always assume they will receive custom errors.
    These assumptions are also made inside catch statements, which is even worse, because if you are working with wrong structure of error there and you try to access a property that doesn't exist, these errors will be silently ignored (because you are in catch already) and the intended functionalities are not met correctly.

Samples of code that does this assumption:
// a method that assumes it always gets generic errors.
function method(param1, param2, param3, cb) {
    method2(param1, function(err, data) {
        if (err) {
            // assume this is generic error and wrap it into custom format, what if it is already FcError?
            var response = new FcError();
            response.addError(err);
            cb(response); // the calling methods need to realize that they will receive always FcError from this method
        } else {
            cb(null, dataToSend);
        }
    });
}
// a method that assumes it always gets FcError errors.
function method(param1, param2, param3, cb) {
    method2(param1, function(err, data) {
        if (err) {
            // assume this is FcError and just bubble it up, what if it is not?
            cb(err);
        }
        else
            cb(null, dataToSend);
    });
}
The problem:

The two different set of "responsibilities" discussed above, creates tightly coupled dependency between the stack structure and the way the code deals with errors, this is unacceptable. The code is increasing the ways it can fail (introduce bugs).

When you want to maintain such code, you must make sure 100% that each function is doing it's proper job with respect to errors, wrapping it or not wrapping it or perhaps unwrapping as well.

If you want to use functions loosely and without worrying about this, you can't, you must at each level check the code of the function(s) you are consuming to "see" what they are returning as errors, not only that, each function would depend on many other functions under it, which will create even more of a problem. We need a better way of dealing with errors. 
Solution:

All function errors should pass through a common function (in case of portal, it is result.error).

This common function will identify the different types of errors and wrap them (if needed) into a common structure while preserving any error information needed, including the type.

It is not enough to use result.error or result.success, to get this done, callbacks will also go through a function called result.cb(...) which will handle the callback result first and wrap the errors as needed, if needed.

While bubbling up the stack via callbacks, the "result" object correctly identifies the error structure and makes sure it is the common structure expected by all functions, regardless of how the error was triggered or in which format it was.
Sample of the solution code:

Please read the comments inside the code.
function method(param1, param2, param3, cb) {
    method2(param1, result.cb(cb, function (data) {
        // work with data, no need to work with an error case (err), if it failed, the result.cb will wrap it correctly, as needed and bubble it up with same format as needed
        // of course if you need to deal with the error specifically at this layer, you don't use result.cb()
        if (data && data.IsOkay)
            return cb(result.success("success data");
        else
            return cb(result.error("error data"); 
        // send up result object
        // the caller will receive "result" object always, even if method2 failed with generic error or custom error, 
        // the result.cb will wrap it correctly if it is generic or just bubble up if it is already a result error.
    });
}
// if you need to do something in error case
function method(param1, param2, param3, cb) {
    method2(param1, function (err, data) {
        if (err) {
            // do stuff needed, like close connection perhaps and delete stuff...
            return cb(result.error(err)); // if err is already result, result.error will correctly identify it and not wrap it. If it is generic error, it will wrap it
        }
        if (data && data.IsOkay)
 
            return cb(result.success("success data");
        else
            return cb(result.error("error data"); 
        // send up result object
        // the caller will receive "result" object always, even if method2 failed with generic error or custom error, 
        // the result.cb will wrap it correctly if it is generic or just bubble up if it is already a result error.
    });
}
Additional benefits:

The "result" object solves other important problems as well.

    The result.cb optionally takes successFn, so you won't need to clutter your code with checking for error in each and every callback. This reduces readability and increases the surface area for bugs. A sample will follow.
    The result engine while wrapping errors can detect certain classes of errors (via regex) and translate them into the correct errorCode that is needed for the application logic. One example is MongoDB code: E11000 duplicate key error index, this is effectively a warning in some situations that the data you want to save will cause duplicates, the presentation layer will need to give out a graceful message in this case and give the chance for fixing the data and resubmitting, as such a specific errorCode is needed. Instead of having to go over the code and identifiying the points where this error might be raised and writing code to search for this specific error and translating it into the proper errorCode, the result.cb will automatically take care of this by searching for /^E11000/.

     
    // traditional method:
    // low readability
    // deal with error in every stage
    // high surface for bugs
    // a lot of dependency between specific function logic/error handling/error translation
     
    function f1(data, cb) {
        f2(data, function(err, data) {
            if (err)
                return cb(err); // perhaps here we need to wrap this error with our internal used Error? maybe, maybe it is wrapped already? additional if statements will be needed
            else {
                f3db(data, function(err, data) {
                    if (err) {
                        if (/^E11000/.test(err))
                            return cb(new FcError(10, err)); // here error code 10 indicates data unique constraint problem
                        else
                            return cb(err);
                    }
                    else {
                        f4(data, function(err, finaldata) {
                            if (err)
                                cb(err);
                            else
                                cb(null, finaldata);                       
                        });
                    }
                });
            }
        });
    }
    // using result:
    // better readability,
    // no need to deal with errors in your code, errors are dealt with correctly, wrapped into common structures, translated via regex if needed
    // lower surface for bugs
    // no dependency between specific function logic/error handling, your code only handles success data, errors are automatically wrapped if needed and triggered back
     
    function f1(data, cb) {
        f2(data, result.cb(cb, function(data) {
            f3db(data, result.cb(cb, function(data) {
                f4(data, result.cb(cb, function(finaldata) {
                    return cb(result.success(finaldata));
                }));
            }));
        }));
    }

Cons:

The cons are very minimal. For each callback another calling stack frame is used (closure), and some extra localized memory usage due to the stack frame and it's closure. However the performance impact tends to zero since the V8 engine is highly optimized when it comes to matters such as localized memory usage and stack frames. Doing tests on a virtual machine with the two cases (one with extra stack frame) with a loop of 10,000 calls did not yield measurable performance degradation.
