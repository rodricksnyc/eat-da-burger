/**
 * Created by Ralph Varjabedian on 12/18/14.
 * require-hook is licensed under the [MIT]
 * do not remove this notice.
 */
'use strict';

var result = {};

// the identifier for a result object
result.obj_id = "__IsResult";
result.verbose = true;

var errors = result.errors = require("./errors");

function Result(success, errorCode, error, errorDetails, data, raw) {
  var errorDef;

  this[result.obj_id] = true;
  this.raw = raw;
  this.success = success;

  // explicitly set to null so that they always appear in the object
  //this.data = (typeof(data) == "undefined") ? null : data;
  this.data = data; //keep undefined if passed
  this.error = (typeof(error) == "undefined") ? null : error;

  if(result.verbose) {
    this.errorDetails = errorDetails;
  }
  this.errorCode = (typeof(errorCode) === "undefined" || errorCode === null) ? errors.defaultErrorCode : errorCode;
  if(this.error && this.error.message && typeof(this.error.message) === "string" && this.error.code && typeof(this.error.code) === "number") {
    // even if we have .message and .code, we still wanna give chance to regex to transform error into a more readable format
    errorDef = errors.find(this.error.message);
    if(errorDef) {
      this.errorCode = errorDef.code;
      if(result.verbose) {
        this.originalError = this.error;
      }
      this.error = errorDef.desc;
      if (errorDef.ext) {
        this.ext = errorDef.ext;
      }
    } else {
      this.errorCode = this.error.code;
      this.error = this.error.message;
    }
  } else if(this.error && this.error.message) {
    if(result.verbose) {
      this.exception = toString.apply(this.error);
    }
    this.error = this.error.message;
  }
  // attempt to locate errors according to regex patterns, this is necessary for errors that come from MongoDB for example.
  if(this.error && this.errorCode == errors.defaultErrorCode) {
    errorDef = errors.find(this.error);
    if(errorDef) {
      this.errorCode = errorDef.code;
      if(result.verbose) {
        this.originalError = this.error;
      }
      this.error = errorDef.desc;
      if (errorDef.ext) {
        this.ext = errorDef.ext;
      }
    }
  }
  if(!result.verbose) {
    // in non verbose mode, if we have errorCode, remove the message details, just put the number
    if(this.errorCode) {
      this.error = this.errorCode;
    }
  }
}

/**
 * A method to indicate a success result
 * @param {(object|Result)} [data] - Data you want to associate with the success state
 * @param {object} [extra] - Data that will be appended to the top-level result object
 * @returns {Result} - The result instance that indicates a success along with attached data
 */
result.success = function(data, extra) {
  if(data && data[result.obj_id]) {
    return data;
  }
  var obj = new Result(true, null, null, null, data);
  if(extra) {
    obj.extra = extra;
  }
  return obj;
};

result.isType = function(obj) {
  return obj && (obj[result.obj_id] === true);
};

/**
 * A method to indicate a success result, an additional flag is added raw=true to indicate to the consuming code that the result is intended to be data only
 * @param {(object|Result)} [data] - Data you want to associate with the success state
 * @param {object} [extra] - Data that will be appended to the top-level result object
 * @returns {Result} - The result instance that indicates a success along with attached data
 */
result.successRaw = function(data, extra) {
  if(data && data[result.obj_id]) {
    return data;
  }
  var obj = new Result(true, null, null, null, data, true);
  if(extra) {
    obj.extra = extra;
  }
  return obj;
};

/**
 * A method to indicate a failed result
 * @param {(string|Error|object|Result)} err - The error object, it can be of many types
 * @param {object} [errorDetails] - Data you want to associate with the error state
 * @returns {Result} - The result instance that indicates an error
 */
result.error = function(err, errorDetails) {
  if(err && err[result.obj_id]) {
    return err;
  }
  return new Result(false, null, err, errorDetails);
};
result.fail = result.failure = result.error;

/**
 * A method to indicate a failed result with pre-configured error Codes
 *
 * you have four flexible ways of calling this with an errorCode
 * result.errorCode(result.codes.notLoggedIn));
 * result.errorCode(1)); - undefined errors codes will revert back to generic
 * result.errorCode("1");
 * result.errorCode("notLoggedIn");
 * @param {(number|object|string|Result)} errorCode - The error code, multiple formats accepted
 * @param [errorDetails] - additional error data
 * @param [data] - Additional data (the same one used in success)
 * @returns {Result} - The result instance that indicates an error
 */
result.errorCode = function(errorCode, errorDetails, data) {
  if(errorCode && errorCode[result.obj_id]) {
    return errorCode;
  }
  var errorDef = errors.get(errorCode);
  var r = new Result(false, errorDef.code, errors.get(errorCode).desc, errorDetails, data);
  if (errorDef.ext) {
    r.ext = errorDef.ext;
  }
  return r;
};

/**
 * embed multiple errors as an error, most probably as an "error" element of the root result object
 * @param errorsArray
 * @param optionalSuccessResult
 * @returns {*}
 */
result.combineErrors = function(errorsArray, optionalSuccessResult) {
  var errors = [];
  for(var i = 0; i < errorsArray.length; i++) {
    if(errorsArray[i] && errorsArray[i][result.obj_id] && !errorsArray[i].success) {
      errors.push(errorsArray[i]);
    }
  }
  if(errors.length > 0) {
    var res = result.error(errors); // embed multiple errors only Results as an array into root one
    res.IsResultArray = true;
    res.errorCode = -2;
    return res;
  } else {
    return optionalSuccessResult ? optionalSuccessResult : result.success();
  }
};

/**
 * This callback is called in case the result is successful
 *
 * @callback resultSuccessFn
 * @param {object} data - The data associated with the success result
 */

/**
 * This callback is called in case the result is a failure
 *
 * @callback resultFailureFn
 * @param {object} error - The error associated with the failed result
 */


/**
 * This method serves a double purpose.
 * 1. When called, it will automatically behave correctly depending on whether the
 *    parameters passed are the standard (err,data) or just the one param (Result instance)
 * 2. In case of error, call the passed in CB with error Result object
 *    If success, call the success function with data (if no successFn, call cb with success Result object)
 * Basically you can use this everywhere to eliminate the need to handle errors in each and every callback!
 * So this method makes it transparent, just deal with the success cases and let the function worry about errors.
 * @param {Function} cb - The callback function, it will call it with Result param
 * @param {resultSuccessFn} [successFn] - An optional function to call in case of success only, otherwise it will bubble up (Result) via the cb
 * @param {resultFailureFn} [failureFn] - An optional function to call in case of error only, otherwise it will bubble up (Result) via the cb
 * @returns {Function} - The generated callback function that should be passed to the function you are calling
 */
result.cb = function(cb, successFn, failureFn) {
  return function(obj, data) {
    if(obj) {
      if(!obj[result.obj_id]) {
        obj = result.error(obj);
      }
    } else {
      obj = result.success(data);
    }
    if(obj.success && successFn) {
      return successFn(obj.data, obj.extra);
    } else if(!obj.success && failureFn) {
      return failureFn(obj.error, obj);
    } else {
      return cb(obj);
    }
  }
};

/**
 * This method is very similar to result.cb
 * However it will take in legacycb instead of cb, this means that when it will bubble up results, it will not pass Result, but the standard node.js error approach cb(err, data)
 * @param {Function} legacycb - The generic callback function of node, it will call it with params (err, data)
 * @param {resultSuccessFn} [successFn] - An optional function to call in case of success only, otherwise it will bubble up via the legacycb
 * @param {resultFailureFn} [failureFn] - An optional function to call in case of error only, otherwise it will bubble up (Result) via the legacycb
 * @returns {Function} - The generated callback function that should be passed to the function you are calling
 */
result.legacycb = function(legacycb, successFn, failureFn) {
  return function(obj, data) {
    if(obj) {
      if(!obj[result.obj_id]) {
        obj = result.error(obj);
      }
    } else {
      obj = result.success(data);
    }
    if(obj.success && successFn) {
      return successFn(obj.data, obj.extra);
    } else if(!obj.success && failureFn) {
      return failureFn(obj.error, obj.data);
    } else {
      if(obj.success) {
        return legacycb(null, obj.data);
      } else {
        return legacycb(obj.error, obj.data);
      }
    }
  }
};

module.exports = result;